#include "TableEditor.hpp"
#include <algorithm>

void TableItem::setData(int role, const QVariant& data)
{  
    bool valid;
    QLocale().toDouble(data.toString(), &valid);

    if(valid || data.toString().isEmpty())
        QTableWidgetItem::setData(role, data);
}

TableEditor::TableEditor(const QList<QString>& labels, int rows)
    : QTableWidget(rows, labels.size())
{
    this->setSelectionMode(QAbstractItemView::ContiguousSelection);
    this->setHorizontalHeaderLabels(labels);
    this->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
    this->horizontalHeader()->setDefaultAlignment(Qt::AlignLeft);
    this->verticalHeader()->sectionResizeMode(QHeaderView::Fixed);
    this->verticalHeader()->setDefaultSectionSize(horizontalHeader()->height());    // Todo: Better way?
    this->verticalHeader()->hide();

    for(int i = 0; i < rowCount(); ++i)
    {
        for(int j = 0; j < columnCount(); ++j)
            this->setItem(i, j, new TableItem());
    }

    // Actions

    auto action_cut = new QAction("&Cut", this);
    QObject::connect(action_cut, &QAction::triggered, this, &TableEditor::cutSelection);
    action_cut->setShortcuts(QKeySequence::Cut);
    this->addAction(action_cut);

    auto action_copy = new QAction("Cop&y", this);
    QObject::connect(action_copy, &QAction::triggered, this, &TableEditor::copySelection);
    action_copy->setShortcuts(QKeySequence::Copy);
    this->addAction(action_copy);

    auto action_paste = new QAction("&Paste", this);
    QObject::connect(action_paste, &QAction::triggered, this, &TableEditor::pasteToSelection);
    action_paste->setShortcuts(QKeySequence::Paste);
    this->addAction(action_paste);

    auto action_delete = new QAction("&Delete", this);
    QObject::connect(action_delete, &QAction::triggered, this, &TableEditor::deleteSelection);
    action_delete->setShortcuts(QKeySequence::Delete);
    this->addAction(action_delete);

    // Context menu

    this->setContextMenuPolicy(Qt::CustomContextMenu);
    QObject::connect(this, &TableEditor::customContextMenuRequested, [=](const QPoint& pos){
        QMenu menu(this);
        menu.addAction(action_cut);
        menu.addAction(action_copy);
        menu.addAction(action_paste);
        menu.addSeparator();
        menu.addAction(action_delete);
        menu.exec(this->viewport()->mapToGlobal(pos));
    });

    // Event handling

    QObject::connect(this, &TableEditor::cellChanged, [&]{
        if(this->state() == QAbstractItemView::EditingState) {
            emit modified();
        }
    });

    QObject::connect(this, &QTableWidget::itemSelectionChanged, this, [&] {
        emit this->rowSelectionChanged(getSelectedRows());
    });
}

MatrixXd TableEditor::getData() const
{

    std::vector<std::vector<double>> temp;
    for(int i = 0; i < rowCount(); ++i)
    {
        std::vector<double> row(columnCount());
        bool any_valid = false;
        for(int j = 0; j < columnCount(); ++j)
        {
            bool valid;
            double value = QLocale().toDouble(this->item(i, j)->text(), &valid);

            row[j] = valid ? value : NAN;
            any_valid = any_valid || valid;
        }

        if(any_valid) {
            temp.push_back(row);
        }
    }

    MatrixXd data(temp.size(), columnCount());
    for(int i = 0; i < data.rows(); ++i)
    {
        for(int j = 0; j < data.cols(); ++j)
            data(i, j) = temp[i][j];
    }

    return data;
}

void TableEditor::setData(const MatrixXd& data)
{
    // Block cellChanged events not generated by user
    bool state = this->blockSignals(true);

    for(int i = 0; i < rowCount(); ++i)
    {
        for(int j = 0; j < columnCount(); ++j)
        {
            if(i < data.rows() && j < data.cols())
            {
                if(std::isnan(data(i, j)))
                    this->item(i, j)->setText("");
                else
                    this->item(i, j)->setText(QLocale().toString(data(i, j), 'g'));
            }
            else
            {
                this->item(i, j)->setText("");
            }
        }
    }

    this->blockSignals(state);
}

void TableEditor::cutSelection()
{
    copySelection();
    deleteSelection();
}

void TableEditor::copySelection()
{
    auto selection = this->selectedRanges();
    if(selection.size() != 1)
        return;

    QString content;
    for(int i = selection[0].topRow(); i <= selection[0].bottomRow(); ++i)
    {
        for(int j = selection[0].leftColumn(); j <= selection[0].rightColumn(); ++j)
        {
            content += this->item(i, j)->text();

            if(j != selection[0].rightColumn())
                content += "\t";
        }

        content += "\r\n";
    }

    QGuiApplication::clipboard()->setText(content);
}

void TableEditor::pasteToSelection()
{
    auto selection = this->selectedRanges();
    if(selection.size() != 1)
        return;

    QString content = QGuiApplication::clipboard()->text();
    QTextStream stream(&content);

    for(int i = selection[0].topRow(); i < rowCount() && !stream.atEnd(); ++i)
    {
        QStringList values = stream.readLine().split("\t");
        QStringListIterator iterator(values);

        for(int j = selection[0].leftColumn(); j < columnCount() && iterator.hasNext(); ++j)
            this->item(i, j)->setText(iterator.next());
    }

    emit modified();
}

void TableEditor::deleteSelection()
{
    auto selection = this->selectedRanges();
    for(auto& range: selection)
    {
        for(int i = range.topRow(); i <= range.bottomRow(); ++i)
        {
            for(int j = range.leftColumn(); j <= range.rightColumn(); ++j)
                this->item(i, j)->setText("");
        }
    }

    emit modified();
}

QVector<int> TableEditor::getSelectedRows()
{
    QVector<int> rows;
    for(int i = 0; i < rowCount(); ++i)
    {
        for(int j = 0; j < columnCount(); ++j)
        {
            if(this->item(i, j)->isSelected())
            {
                rows.push_back(i);
                break;
            }
        }
    }

    return rows;
}
